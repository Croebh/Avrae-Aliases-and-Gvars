embed

<drac2>

# ------------------
# | Constants, etc |
# ------------------

SaveTypes = ["dex", "str", "con", "wis", "int", "cha"]
StatTypes = ["dexterity", "strength", "constitution", "wisdom", "intelligence", "charisma"]
NewLine   = "\n"

init = combat()

# ---------------
# | Arg Parsing |
# ---------------

a     = &ARGS&
c     = []

args  = argparse(a)

out   = args.last('out')

# Loop through our resources uvar/svar
cgvar = {}
for gvar in load_json(get_svar('useResources', '[]')) + load_json(get('resources','[]')):
 # If its a valid gvar, add it to the list
 if (gvarLoad := get_gvar(gvar)) and typeof((gvarLoad := load_json(gvarLoad)))=="SafeDict":
  cgvar.update(gvarLoad)
 # Otherwise, inform the user that it was invalid
 else:
  return f""" -title "Invalid GVAR: `{gvar}`"
  -desc "Please remove it from either your `resources` uvar, or your `useResources` svar." """

cvar  = args.last('cvar') or (a[0] if a else '{}')
# If we have a cvar, lets add it to our args
if input := (get(cvar) or cgvar.get(cvar)):
 # If it was a cvar and not in the gvar, load it as a json
 if typeof(input) == "str":
  input = load_json(input)
 # Loop over each item in the var
 for arg, item in input.items():
  # If it was a list (such as preset targets), add them all
  if typeof(item) == "SafeList":
   for iterItem in item:
    c.extend([f"-{arg}", iterItem])
  # Otherwise just add it
  else:
   c.extend([f"-{arg}", item])

# Reparse with the new arg list
args = argparse(c + a)

totalDamage = 0
anno = {}

user = init.get_combatant(args.last('user', name)) or character()
name = user.name if user else name

# Misc
anno["n"]           = args.last("n",     "", str)
anno["ndesc"]       = args.last("ndesc", "", str)
anno["roll"]        = args.last("roll",  "", str)

# One Off
anno["dc"]          = args.last('dc',   "10", str)
crit                = args.last('crit', False, bool)
save_type           = args.last('save', args.last('s', 'dex')).lower()[:3]

# General
anno["save_bonus"]  = args.get('b')
anno["damage"]      = args.last('d',           "", str)
anno["maxhp"]       = args.last('max',         "", str)
anno["temphp"]      = args.last('thp',         "", str)
anno["effect"]      = args.last("effect",      "", str)
anno["effectdesc"]  = args.last("effectdesc",  "", str)
anno["seffect"]     = args.last("seffect",     "", str)
anno["seffectdesc"] = args.last("seffectdesc", "", str)

# Flavour
anno["phrase"]      = args.join('phrase', NewLine, "")
anno["desc"]        = args.last('desc',   '', str)
anno["thumb"]       = args.last('thumb',
                                 image if character().name == user.name else
                                 "https://cdn.discordapp.com/attachments/349765584302505985/597101368117035038/246x0w.png", str)
anno["color"]       = args.last('color',  color, str)
anno["image"]       = args.last('image',  "", str)
anno["title"]       = args.last('title',  f'{name} wants you to make a {StatTypes[SaveTypes.index(save_type)].title()} Save!', str)

# We need this to be a dict for the annotating below
targetsCache       = {i:targ for i, targ in enumerate(args.get('t'))}

gAutoPass          = args.adv(custom={'adv': 'pass', 'dis': 'fail'})

# Clear out unused args
for arg in anno.copy():
 if not anno.get(arg):
  anno.pop(arg)

# ---------------------------
# | Annotate all the Things |
# ---------------------------

mathsep   = "+-()/*[]"
for annoGroup in [anno, targetsCache]:
 for key, string in annoGroup.items():
  # Get all parts enclosed in {braces}
  bracedSegments = [(part := part.split('{')[0])[:part.index('}')] for part in string.split('{') if '}' in part]
  stringOut = []
  # Iterate over each one
  for segment in bracedSegments:
   segOut = []
   # Separate out things in mathsep, with spaces
   sepSegment = "".join([(f" {char} " if char in mathsep else char) for char in segment]).split()
   # Iterate over each part
   for sep in sepSegment:
    # If its a number, or a math seperator, add it to the output unchanged
    if (sep.strip('-.').isdigit() or sep in mathsep):
     segOut.append(sep)
    # If a annotated exists, add that
    elif anno.get(sep) is not None:
     if typeof(anno.get(sep)) == "SimpleRollResult":
      segOut.append(str(anno.get(sep).total))
     else:
      segOut.append(str(anno.get(sep)))
    # If an -arg was provided with this name, add that
    elif args.last(sep) is not None:
     segOut.append(str(args.last(sep)))
    # If a variable exists, add that
    elif get(sep) is not None:
     segOut.append(str(get(sep)))
    # Otherwise add it unchanged
    else:
     segOut.append(sep)
   # Convert it to a string
   segOut = ''.join(segOut)
   # Roll and append (invalid roll() return 0)
   stringOut.append(roll(segOut) if segOut.strip('+-').isdigit() else roll(segOut) or segOut)
  # Replace the original string
  for i, origin in enumerate(bracedSegments):
   string = string.replace("{"+origin+"}", str(stringOut[i]))
  # Roll our rollables
  if key in ["damage", "maxhp", "temphp", "dc", "roll", "n"]:
   if key in ["dc", "n"]:
    annoGroup[key] =  roll(string)
   elif key in ["maxhp", "temphp", "roll", "damage"]:
    annoGroup[key] = vroll(string, 1 + (crit if key == "damage" else 0))
  else:
   annoGroup[key] = string

# ----------------------------------
# | Args part two elecric boogaloo |
# ----------------------------------

# Ignore Certain Args so we aren't reparsing them in the target loop
args.ignore('d')
args.ignore('max')
args.ignore('thp')
args.ignore('pass')
args.ignore('fail')

# ---------------
# | Consumables |
# ---------------

# Default to 'everything is fine'
valid           = True

consumeOut      = []
consumes        = {"cc": {}, "slot": {}, "item": {}}
invalidConsumes = {"cc": [], "slot": [], "item": []}

# Can only access counters on the active character
if user and user.name == name:
 for counterNum in [""]+[str(x) for x in range(1,11)]:
  if cc := args.last('cc' + counterNum):
   ccUses = args.last('ccnum' + counterNum, 1, int)
   # Was it an exact match?
   if character().cc_exists(cc):
    cc = character().cc(cc)
   # Otherwise, loop through all counters and fuzzy search
   else:
    for counter in character().consumables:
     if cc.lower() in counter.name.lower():
      cc = counter
      break
    # If we got through the whole for loop with nothing, no matches
    else:
     cc = None
   # Did we find a valid counter? Add it to the consumes dic
   if cc:
    consumes["cc"].update({cc: consumes["cc"].get(cc.name, 0) - ccUses})

for slotNum in [""]+[str(x) for x in range(1,11)]:
 if slot := args.last('slot' + slotNum):
  slotUses = args.last('slotnum' + slotNum, 1, int)
  # Does that character even have slots of that level?
  if user.spellbook.get_max_slots(slot):
   consumes["slot"].update({int(slot): consumes["slot"].get(int(slot), 0) - slotUses})


# Make sure all counters won't be made out of bounds (need to add spell slots and items to this too)
counterValid = all([1 if cc.min <= (cc.value + ccUses) <= cc.max else invalidConsumes["cc"].append(f"""**{cc.name}** ({ccUses:+}): {str(cc)}""") for cc, ccUses in consumes["cc"].items()])
slotValid = all([1 if 0 <= (user.spellbook.get_slots(slot) + slotUses) <= user.spellbook.get_max_slots(slot) else invalidConsumes["slot"].append(f"""{user.spellbook.slots_str(slot)} ({slotUses:+})""") for slot, slotUses in consumes["slot"].items()])

if not args.last('i'):
 if counterValid and slotValid:
  # If everything was valid, go through and modify them all
  for cc, ccUses in consumes["cc"].items():
   cc.set(cc.value + ccUses)
   consumeOut.append(f""" -f "{cc.name} ({-ccUses:+})|{str(cc)}" """)
  slotOut = []
  for slot, slotUses in consumes["slot"].items():
   user.spellbook.set_slots(slot, user.spellbook.get_slots(slot) + slotUses)
   slotOut.append(f"""{user.spellbook.slots_str(slot)} ({slotUses:+})""")
  else:
   consumeOut.append(f"""  -f "Slots Remaining|{NewLine.join(slotOut)}" """) if slotOut else None

 # Otherwise, something would go out of bounds, cancel everything and inform the user
 else:
  consumeOut.append(f""" -f "Consumable out of Bounds|Unfortunately, one or more of your consumables would be put out of bounds by this action:
   {NewLine.join(invalidConsumes["cc"]) if invalidConsumes["cc"] else ""}
   {NewLine.join(invalidConsumes["slot"]) if invalidConsumes["slot"] else "" }" """.replace("   ","").replace("\n\n", "\n"))
  valid = False

# ------------------
# | Effect Parsing |
# ------------------

# Targetted Effects
if anno.get('effect'):
 effect = {}
 eSplit  = anno.get('effect').split('|')
 # First arg should always be there
 effect["name"] = eSplit.pop(0)
 effect["args"] = ""
 effect["dur"]  = -1

 # If theres only one arg left, it'd be args
 if len(eSplit) == 1:
   effect["args"] = eSplit.pop(0)
 # If its two, its args and duration
 elif len(eSplit) == 2:
   effect["args"] = eSplit.pop(0)
   effect["dur"]  = eSplit.pop(0)
 # If its 3 or more, and has -attack, account for that
 elif len(eSplit) >= 3 and '-attack' in anno.get('effect'):
   # Count how many -attack are in the args
   aCount = anno.get('effect').count('-attack')*3
   effect["args"] = '|'.join(eSplit[:aCount])
   effect["dur"]  = (eSplit[aCount:] or [-1])[0]

 # Handle our special arguments
 effectArgs = argparse(effect["args"])
 for special in ["end", "conc", "desc"]:
  effect[special] = effectArgs.last(special)

 anno["effect"] = effect

# Self Effects
if anno.get('seffect'):
 effect = {}
 eSplit  = anno.get('seffect').split('|')
 # First arg should always be there
 effect["name"] = eSplit.pop(0)
 effect["args"] = ""
 effect["dur"]  = -1

 # If theres only one arg left, it'd be args
 if len(eSplit) == 1:
   effect["args"] = eSplit.pop(0)
 # If its two, its args and duration
 elif len(eSplit) == 2:
   effect["args"] = eSplit.pop(0)
   effect["dur"]  = eSplit.pop(0)
 # If its 3 or more, and has -attack, account for that
 elif len(eSplit) >= 3 and '-attack' in anno.get('effect'):
   # Count how many -attack are in the args
   aCount = anno.get('effect').count('-attack')*3
   effect["args"] = '|'.join(eSplit[:aCount])
   effect["dur"]  = (eSplit[aCount:] or [-1])[0]

 # Handle our special arguments
 effectArgs = argparse(effect["args"])
 for special in ["separate", "parent", "end", "conc", "desc"]:
  effect[special] = effectArgs.last(special)

 anno["seffect"] = effect

# -------------------
# | Get Target Loop |
# -------------------

targets   = []
targetOut = []
for targ in targetsCache.values():
  targName, targArgs = (targ.split("|")+[""])[:2]
  targArgs = argparse(targArgs)
  if curTarg := init.get_combatant(targName):
   targets.append(curTarg)
   args.add_context(curTarg.name, targArgs)
  elif curTarg := init.get_group(targName):
   for gTarg in curTarg.combatants:
    targets.append(gTarg)
    args.add_context(gTarg.name, targArgs)

# --------------------
# | Main Target Loop |
# --------------------

for target in targets:
 tOut = []

 # Grab our specific targets arguments
 args.set_context(target.name)
 autoPass = args.adv(custom={'adv': 'pass', 'dis': 'fail'})

 # Figure out our entire damage string
 targDamage = anno["damage"].consolidated() if anno.get("damage") else ""
 if targD := args.get('d'):
  targDamage += "+" + "+".join(targD)

 # Figure out our entire max hp adjustment
 targMaxhp = anno["maxhp"].consolidated() if anno.get("maxhp") else ""
 if targM := args.get('max'):
  targMaxhp += "+" + "+".join(targM)

 # Figure out our entire temp hp adjustment
 targTemphp = anno["temphp"].consolidated() if anno.get("temphp") else ""
 if targT := args.get('thp'):
  targTemphp += "+" + "+".join(targT)

 # If we aren't automatically passing or failing
 if not (gAutoPass or autoPass):

  # Figure out all of our save bonuses
  save_bonus = anno.get("save_bonus", [])
  adv = args.adv(boolwise=True)
  for effect in target.effects:
   if (sb := effect.effect.get('sb')):
     save_bonus.append(sb)

  # Grab our save string and add our bonuses
  saveStr  = target.saves.get(save_type).d20(adv)
  saveStr += '+'.join(save_bonus).replace('+-', '-')

  # Roll the save and compare against the DC
  save     = vroll(saveStr)
  success  = save.total >= anno["dc"]

  tOut.append(f"""**{save_type.upper()} Save:** {save}; {["Failure", "Success"][success]}!""")
 elif gAutoPass:
  # Global flag (1 is true, -1 is false)
  success = gAutoPass == 1
 else:
  # Target flag (1 is true, -1 is false)
  success = autoPass == 1
  tOut.append(f"""**{save_type.upper()} Save:** Automatic {["Failure", "Success"][success]}!""")

 # If they failed, do things to them
 if not success:
  # Do we have damage? If so, apply it and add to total
  if targDamage:
   if args.last('avoid'):
    targDamage = f"""({targDamage})/2"""
   targDamage = target.damage(targDamage, crit)
   totalDamage += targDamage.total
   tOut.append(targDamage.damage)
  # Do we have a max hp adjustment? If so, apply it and add to total
  if targMaxhp:
   targMaxhp = vroll(targMaxhp)
   target.set_maxhp(target.max_hp + targMaxhp.total)
   # Was there a specific adjustment?
   if targMaxhp.total != anno.get("maxhp", {"total": None}).total:
    tOut.append(f"""**Max HP Roll:** {targMaxhp}""")
   tOut.append(f"""Max HP {["Decreased", "Increased", "Unchanged"][(targMaxhp.total>=0) + (targMaxhp==0)]}: `{targMaxhp.total:+}`""")
  # Do we have a max hp adjustment? If so, apply it and add to total
  if targTemphp:
   targTemphp = vroll(targTemphp)
   # Was there a specific adjustment?
   if targTemphp.total != anno.get("temphp", {"total": None}).total:
    tOut.append(f"""**Temp. HP Roll:** {targTemphp}""")
   if targTemphp.total > target.temp_hp:
    target.set_temp_hp(targTemphp.total)
    tOut.append(f"""Temp. HP Set: `{targTemphp.total}`""")
   else:
    tOut.append(f"""Temp. HP Unchanged: `{target.temp_hp}`""")
  # Are we adding an effect?
  if tEffect := anno["effect"]:

   # Set our parent effect (Defaulting to None)
   parent = None
   # If we're parenting the effect to a target, we need to make sure that effect exists
   if (sEffect := anno["seffect"]) and sEffect.get('parent') and typeof(user) == "SimpleCombatant":
    # Are we created one parent effect?
    if not sEffect.get('separate'):
     # If the parent effect doesn't exist yet, lets create it
     if not sEffect.get('created'):
      user.add_effect(sEffect["name"], sEffect["args"], sEffect["dur"], sEffect["conc"], end=sEffect["end"], desc=anno.get("seffectdesc"))
      sEffect["created"] = [(parent := user.get_effect(sEffect["name"]))]
    # Otherwise, we need to append or replace the targets name (so our effects don't overwrite)
    else:
     if "[tname]" not in sEffect["name"]:
      sName = sEffect["name"] + f" - {target.name}"
     else:
      sName = sEffect["name"].replace("[tname]", target.name)
     user.add_effect(sName, sEffect["args"], sEffect["dur"], sEffect["conc"], end=sEffect["end"], desc=anno.get("seffectdesc"))
     sEffect["created"] = sEffect.get("created", []) + [(parent := user.get_effect(sName))]
   # Finally, add our effect
   target.add_effect(tEffect["name"], tEffect["args"], tEffect["dur"], tEffect["conc"], parent, tEffect["end"], anno.get("effectdesc"))
   tOut.append(f"""**Effect:** {str(target.get_effect(tEffect["name"])).splitlines()[0]}""")

 else:
  # Do we have damage and half/avoid? If so, apply it and add to total
  if targDamage:
   if args.last('avoid'):
    targDamage = f"""({targDamage})*0"""
   elif args.last('half'):
    targDamage = f"""({targDamage})/2"""
   targDamage = target.damage(targDamage, crit)
   totalDamage += targDamage.total
   tOut.append(targDamage.damage)

 # Add our target output to the list
 targetOut.append(f""" -f "{target.name}|{NewLine.join(tOut) or "*None*"}|inline" """)

 # Reset our context
 args.set_context(None)

# -------------------
# | Self Targetting |
# -------------------

userOut = []
# Is the user an active combatant?
if typeof(user) == "SimpleCombatant":
 # Lets do effects first (only?)
 # If we have an seffect, and wasn't already created
 # and not just not made because everyone passed their save
 if (sEffect := anno["seffect"]) and not sEffect.get('created') and not 'parent' in sEffect.get('args'):
  user.add_effect(sEffect["name"], sEffect["args"], sEffect["dur"], sEffect["conc"], end=sEffect["end"], desc=anno.get("seffectdesc"))
  sEffect["created"] = sEffect.get("created", []) + [user.get_effect(sName)]
 for effect in sEffect.get("created"):
  userOut.append(f"""**Effect:** {str(effect).splitlines()[0]}""")

if userOut:
 userOut = f""" -f "{user.name}|{NewLine.join(userOut)}" """
else:
 userOut = ""

# ---------------
# | Meta Output |
# ---------------

metaOut = []
if valid:
 if anno.get("damage"):
  metaOut.append(f"""**Damage:** {anno["damage"]}""")
 if anno.get("maxhp"):
  metaOut.append(f"""**Max HP:** {anno["maxhp"]}""")
 if anno.get("temphp"):
  metaOut.append(f"""**Temp. HP:** {anno["temphp"]}""")
 if anno.get('n'):
  metaOut.append(f"""**{anno.get('ndesc', 'Number')}**: {anno.get('n')}""")
 if anno.get('roll'):
  metaOut.append(f"""**Roll**: {anno.get('roll')}""")
 # We don't need save info if everyone auto fail/passes
 if not gAutoPass:
  metaOut.append(f"""**DC:** {anno["dc"]}""")
  metaOut.append(f"""{save_type.upper()} save""")
if metaOut:
 # Join it together
 metaOut = f""" -f "Meta|{NewLine.join(metaOut)}" """
else:
 metaOut = ""

# ------------------
# | Flavour Output |
# ------------------

flavourOut   = ""
flavourOut  += f""" -title "{anno.get("title")}" """
flavourOut  += f""" -color {anno.get('color')} """
flavourOut  += f""" -thumb {anno.get('thumb')} """
flavourOut  += f""" -image {anno.get('image')} """
if anno.get("desc"):
 flavourOut += f""" -f "Effect|{anno.get("desc")}" """
if anno.get("phrase"):
 flavourOut += f""" -desc "*{anno.get("phrase")}*" """

consumeOut = ' '.join(consumeOut)

return metaOut + userOut + NewLine.join(targetOut) + consumeOut + flavourOut + f""" -footer "{NewLine.join([str(targ) for targ in targets])}" """
</drac2>